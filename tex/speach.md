* Слайд "Тема работы"

Защищается студент группы с8503а Кевролетин Василий Владимирович.
Тема работы: доработка языка программирования Free Pascal: реализация замыканий.
Руководитель: старший преподаватель кафедры информатики,
математического и компьютерного моделирования, Кленин Александр
Сергеевич.

* Слайд "Технические особенности"

FPC - оптимизирующий компилятор, поддерживающий несколько диалектов
языка программирования Pascal. Главная его особенность - поддержка
большого числа целевых процессоров и операционных систем. FPC - проект
с отрытым исходным кодом. Его разрабатывает постоянная команда
волонтёров, которые так же принимают доработки от сторонних
разработчиков.

Основное средство коммуникации разработчиков - список рассылок
электронных писем. В последнее время там неоднократно обсуждалась
необходимость реализации замыканий.

Слайд "Краткое описание замыканий"

*Замыкание - это функция вместе с сохранённым в момент её
создания окружением.*

Используя аналогию с известным понятием "объект", можно дать следующее
неформальное понятие замыкания.
Если объект это данные плюс функции, которые работают с этими даными, то
замыкание это одна функция плюс данные, с которыми она работает.

В императивных языках программирования замыкания - это *лаконичный*
способ создать объект, не требующий объявлять класс этого объекта.
На примере, приведённом на слайде, результатом работы функии
Make Accumulator является замыкание: анонимная функция, связанная
с переменной value.

* Слайд "Анонимные фукнции"

Перед тем как рассмотреть замыкания подробнее я уделю внимание 
смежным понятиям - анонимным и вложенным функциям.

В некоторых языках программирования, анонимные функции - единственный
способ создать замыкание. Тем не менее эти понятия не тождественны.
Анонимная функция - это функция не имеющая идентификатора. Существуют
языки программирования, поддерживающие анонимные функции, но не
поддерживающие замыкания.

* Слайд "Вложенные фукнции"

Многие языки программирования поддерживают вложенные именованные
функции. Вложенная функция может обращаться к переменным внешней
функции. Без поддержки замыканий ссылка на вложенную функцию не
сохраняет окружение. Это значит, что вложенную фукнцию нельзя
вызывать по сохранённой ссылке после того, как работа объемлющей
функции завершилась.

* Слайд "Больше о замыканиях"

Замыкание в момент создания сохраняет используемое окружение.
Типичной является ситуация, когда замыкание использует локальные переменные
объемлющей функции. Без поддержки замыканий время жизни локальных
переменных ограничено временем выполнения функции, где она объявлена.
Время жизни переменной, захваченной из замыкания заканчивается только
когда не осталось использующих её замыканий.

* Слайд "Захват по ссылке"

Существует 2 способа сохранения окружения в замыкании. Первый способ -
захват переменных по ссылке. В момент своего создания замыкание
сохраняет ссылки на данные, поэтому одна и та же переменная может быть
доступна из нескольких замыканий.

* Слайд "Захват по значению"

Второй способ - захват переменных по значению. В момент создания
замыкание запоминает текущее значение захваченных переменных.
Пример приведён на языке программирования с++, потому другие рассмотренные
языки с замыканиями не поддерживают захват переменных по ссылке.

* Слайд "Обзор аналогичных решений"

Сегодня *большинство* популярных языков программирования поддерживают
замыкания. В некоторые из них замыкания были добавлены недавно. К
примеру, в стандарт с++ замыкания были добавлены в 2011м году. В Java
полная поддержка замыканий станет доступной в версии Java 8,
выход которой запланирован на середину этого года.

* Слайд "Сложности управления памятью"

Цель моей работы - реализовать поддержку замыканий в компиляторе Free Pascal.

Одна из основных сложностей реализации заключается в управлении динамической
памятью. Дело в том, что память под захваченные переменные необходимо
выделять в куче. Ручное управление этой памятью снижает пользу замыканий,
так как осложняет их использование.

К счастью, Free Pascal содержит сборщик мусора
//, правда работающий не для всех типов данных. 
Предложенная мной реализация управляет памятью замыканий 
автоматически, используя сборщик мусора. 

* Слайд "Преобразование замыканий"

Кратко рассмотрим структуру компилятора.

Компилятор считывает исходную программу, разбирает её структуру и переводит
во внутреннее представление. Синтаксические конструкции хранит структура
данных под названием "синтаксическое дерево". Информацию о переменных и типах
хранят "таблицы символов". После разбора внутреннее представление используется для
проверки корректности программы и генерации кода.

В случае включенной оптимизации, перед генерацией кода компилятор трансформирует
синтаксическое дерево. Цель трансформаций -- преобразовать исходную программу
в эквивалентную, но более эффективную программу.

Выполненная мной реализация использует похожий подход под названием
"преобразование замыканий". Он состоит в том, чтобы
преобразовать исходную программу с замыканиями в эквивалентную
программу без замыканий. Для этого приходится модифицировать синтаксическое
дерево и добавлять новые типы в таблицы символов.

* Слайд "Преобразование замыканий. Анализ"

Рассмотрим преобразование замыканий на примере.
Сначала необходимо пометить захваченные переменные. В данном случае анонимная
функция захватывает локальные переменные d1 и d2 объемлющей функции.

* Слайд "Преобразование замыканий. Создание копии"

Захваченные переменные нужно выделить в куче. Для это создаётся объект-хранилище
в который переносятся все захваченные переменные функции. 
Захваченнst переменнst становятся полями созданного объекта.

* Слайд "Преобразование замыканий. Перенаправление доступа"

Доступ к захваченной переменной нужно заменить на доступ к соответствующему
полю хранилища.

* Слайд "Преобразование замыканий. Лямбда функции"

Анонимную функцию необходимо преобразовать так, чтобы она не использовала
захваченные переменные напрямую. Вместо этого она должна принимать хранилище
с захваченными переменными в качестве параметра. В языке Free Pascal так
работают методы объекта. Поэтому анонимная функция становится методом
объекта, хранящего захваченные переменные.

* Слайд "Преобразование замыканий. Перенаправление доступа внутри метода"

Аналогично, в созданном методе, доступ к захваченным переменным нужно заменить на доступ к 
соответствующем полям хранилища. 

* Слайд "Преобразование замыканий. Ссылка на объект"

Ссылку на замыкание было бы логично сделать ссылкой на метод объекта.
К сожалению, в FPC сборщик мусора не работает с указателями на методы.
Зато, он работает с указателями на интерфейсы. В языке FPC интерфейс
это аналог множественного наследования.

* Слайд "Преобразование замыканий. Интерфейсы1"

Таким образом, для анонимной фукнции
объявляется интерфейс со счётчиком ссылок, содержащий только один метод,
а объект-хранилище реализует этот интерфейс.
Вместо ссылки на метод замыкание становится ссылкой на интерфейс, содержащий
только один метод. 

* Слайд "Преобразование замыканий. Интерфейсы2"

Через интерфейс можно вызвать нужную преобразованную функцию. 

Главное преемущество описанного подхода - простота. Программа преобразуется в эквивалентную,
использующую давно реализованные и отлаженные возможности компилятора. Это позволяет избежать
изменений в генераторе кода и библиотеке времени исполнения, что особенно актуально для
компилятора FPC.

* Слайд "Вывод"

В ходе выполенения дипломной работы мною были:
- изучены современные подходы разработки компиляторов для языков программирования;
- изучены способы реализации замыканий и спроектирована реализация для конктретного компилятора
- улучшены навыки работы в команде программистов и получены навыки участия в проектах с
открытым исходным кодом

И, наконец, запрограммирована реализация замыканий для компилятора Free Pascal

Наличие замыканий увеличивает привлекательность компилятора для пользователей, потому что
- замыкания являются современной популярной техникой программирования
- наличие замыканий увеличивают совместимость с компилятором Delphi

Можно с уверенностью сказать, что в скором времени пользователи Free Pascal смогут
писать свои программы с использованием современной техники программирования -- замыканий.

Спасибо за внимание.


* Слайд "Вложенные функции"

Стоит отдельно отметить, что Pascal поддерживает вложенные функции.
Поэтому замыкание может захватить переменную любой объемлющей функции.
Кроме того, замыкание в своём теле может создать другое замыкание, 
которое тоже может захватывать доступные в её лексическом 
контексте переменные.

Для реализации доступа к захваченным переменным при большом уровне
вложенности используется следующий подход.
Во время создания нового объекта-хранилища сохраняется ссылка
на предудущее созданное хранилище. В общем случае получается дерево,
в узлах которого находятся хранилища захваченных переменных.
Структура дерева соответствует вложенности фукнций исходной программы.
Доступ к захваченным переменным при большом уровне вложенности
осуществляется аналогично уже рассмотренному случаю, только для доступа
к нужному хранилищу используются ссылки на предыдущее хранилище.
